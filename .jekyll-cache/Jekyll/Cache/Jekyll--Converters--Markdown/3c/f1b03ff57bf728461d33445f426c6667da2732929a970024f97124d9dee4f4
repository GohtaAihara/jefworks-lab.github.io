I"‚~<h1 id="graph-based-community-detection-for-clustering-analysis-in-r">Graph-based community detection for clustering analysis in <code class="highlighter-rouge">R</code></h1>

<h2 id="introduction">Introduction</h2>

<p>In single cell analyses, we are often trying to identify groups of transcriptionally similar cells, which we may interpret as distinct cell types or cell states. We may also be interested in identifying groups of transcriptionally coordinated genes, which we may interpret as functional regulatory modules or pathways. In either case, we are looking at some high dimensional data and trying to identify clusters.</p>

<p>We can also think of these clusters as communities in a graph. Abstractly, our graph would just be composed of all our cells as vertices. And the vertices would, in theory, be connected to each other if the cells were of the same cell type. Community detection in graphs identify groups of vertices with higher probability of being connected to each other than to members of other groups.</p>

<p>In this tutorial, I will use simulated and public data to demonstrate how you can apply graph-based community detection to identify cell types.</p>

<h2 id="simulation">Simulation</h2>

<p>First, letâ€™s simulate some data. We will simulate 5 very clearly distinct cell types and see if we can use graph-based community detection to correctly recover the true cell type annotations.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">G</span><span class="o">=</span><span class="m">5</span><span class="w"> </span><span class="c1">## number of cell types</span><span class="w">
</span><span class="n">N</span><span class="o">=</span><span class="m">100</span><span class="w"> </span><span class="c1">## number of cells per cell type</span><span class="w">
</span><span class="n">M</span><span class="o">=</span><span class="m">1000</span><span class="w"> </span><span class="c1">## number of genes</span><span class="w">
</span><span class="n">initmean</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="c1">## baseline mean expression</span><span class="w">
</span><span class="n">initvar</span><span class="o">=</span><span class="m">10</span><span class="w"> </span><span class="c1">## baseline expression variance</span><span class="w">
</span><span class="n">upreg</span><span class="o">=</span><span class="m">10</span><span class="w"> </span><span class="c1">## degree of cell-type specific upregulation</span><span class="w">
</span><span class="n">upregvar</span><span class="o">=</span><span class="m">10</span><span class="w"> </span><span class="c1">## expression variance of upregulated genes</span><span class="w">
</span><span class="n">ng</span><span class="o">=</span><span class="m">100</span><span class="w"> </span><span class="c1">## number of upregulated genes per cell type</span><span class="w">
</span><span class="n">seed</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="c1">## random seed</span><span class="w">

</span><span class="n">set.seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span><span class="w">
</span><span class="n">mat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">matrix</span><span class="p">(</span><span class="n">rnorm</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">M</span><span class="o">*</span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">initmean</span><span class="p">,</span><span class="w"> </span><span class="n">initvar</span><span class="p">),</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">*</span><span class="n">G</span><span class="p">)</span><span class="w">
</span><span class="n">rownames</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">paste0</span><span class="p">(</span><span class="s1">'gene'</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">M</span><span class="p">)</span><span class="w">
</span><span class="n">colnames</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">paste0</span><span class="p">(</span><span class="s1">'cell'</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">G</span><span class="p">))</span><span class="w">
</span><span class="n">group</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">factor</span><span class="p">(</span><span class="n">sapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="nf">rep</span><span class="p">(</span><span class="n">paste0</span><span class="p">(</span><span class="s1">'group'</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">N</span><span class="p">)))</span><span class="w">
</span><span class="nf">names</span><span class="p">(</span><span class="n">group</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colnames</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="w">

</span><span class="n">diff</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">diff</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rownames</span><span class="p">(</span><span class="n">mat</span><span class="p">)[(((</span><span class="n">x</span><span class="m">-1</span><span class="p">)</span><span class="o">*</span><span class="n">ng</span><span class="p">)</span><span class="m">+1</span><span class="p">)</span><span class="o">:</span><span class="p">(((</span><span class="n">x</span><span class="m">-1</span><span class="p">)</span><span class="o">*</span><span class="n">ng</span><span class="p">)</span><span class="o">+</span><span class="n">ng</span><span class="p">)]</span><span class="w">
    </span><span class="n">mat</span><span class="p">[</span><span class="n">diff</span><span class="p">,</span><span class="w"> </span><span class="n">group</span><span class="o">==</span><span class="n">paste0</span><span class="p">(</span><span class="s1">'group'</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)]</span><span class="w"> </span><span class="o">&lt;&lt;-</span><span class="w"> </span><span class="n">mat</span><span class="p">[</span><span class="n">diff</span><span class="p">,</span><span class="w"> </span><span class="n">group</span><span class="o">==</span><span class="n">paste0</span><span class="p">(</span><span class="s1">'group'</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rnorm</span><span class="p">(</span><span class="n">ng</span><span class="p">,</span><span class="w"> </span><span class="n">upreg</span><span class="p">,</span><span class="w"> </span><span class="n">upregvar</span><span class="p">)</span><span class="w">
    </span><span class="nf">return</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="w">
</span><span class="p">})</span><span class="w">
</span><span class="nf">names</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">paste0</span><span class="p">(</span><span class="s1">'group'</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">G</span><span class="p">)</span><span class="w">

</span><span class="n">mat</span><span class="p">[</span><span class="n">mat</span><span class="o">&lt;</span><span class="m">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">0</span><span class="w">
</span><span class="n">mat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="o">/</span><span class="n">colSums</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span><span class="w">
</span><span class="n">mat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">log10</span><span class="p">(</span><span class="n">mat</span><span class="o">*</span><span class="m">1e6+1</span><span class="p">)</span><span class="w">

</span><span class="n">heatmap</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span><span class="w"> </span><span class="n">Rowv</span><span class="o">=</span><span class="kc">NA</span><span class="p">,</span><span class="w"> </span><span class="n">Colv</span><span class="o">=</span><span class="kc">NA</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="o">=</span><span class="n">colorRampPalette</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="s1">'blue'</span><span class="p">,</span><span class="w"> </span><span class="s1">'white'</span><span class="p">,</span><span class="w"> </span><span class="s1">'red'</span><span class="p">))(</span><span class="m">100</span><span class="p">),</span><span class="w"> </span><span class="n">scale</span><span class="o">=</span><span class="s2">"none"</span><span class="p">,</span><span class="w"> </span><span class="n">ColSideColors</span><span class="o">=</span><span class="n">rainbow</span><span class="p">(</span><span class="n">G</span><span class="p">)[</span><span class="n">group</span><span class="p">],</span><span class="w"> </span><span class="n">labCol</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">labRow</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="http://localhost:4000/assets/blog/graphsim-1.png" alt="" /></p>

<p>To apply graph-based community detection algorithms, we will need to represent our data as a graph. To do this, we will use the <code class="highlighter-rouge">RANN</code> to identify approximate nearest neighbors.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">RANN</span><span class="p">)</span><span class="w">
</span><span class="n">knn.info</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">RANN</span><span class="o">::</span><span class="n">nn2</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">mat</span><span class="p">),</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="m">30</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>The result is a list containing a matrix of neighbor relations and another matrix of distances. We will convert this neighbor relation matrix into an adjacency matrix.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">knn</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">knn.info</span><span class="o">$</span><span class="n">nn.idx</span><span class="w">
</span><span class="n">adj</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">matrix</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">ncol</span><span class="p">(</span><span class="n">mat</span><span class="p">),</span><span class="w"> </span><span class="n">ncol</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span><span class="w">
</span><span class="n">rownames</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colnames</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colnames</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="w">
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nf">seq_len</span><span class="p">(</span><span class="n">ncol</span><span class="p">(</span><span class="n">mat</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">colnames</span><span class="p">(</span><span class="n">mat</span><span class="p">)[</span><span class="n">knn</span><span class="p">[</span><span class="n">i</span><span class="p">,]]]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Now, we can represent the adjacancy matrix as a graph.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">igraph</span><span class="p">)</span><span class="w">
</span><span class="n">g</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">igraph</span><span class="o">::</span><span class="n">graph.adjacency</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="o">=</span><span class="s2">"undirected"</span><span class="p">)</span><span class="w">
</span><span class="n">g</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">simplify</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="c1">## remove self loops</span><span class="w">
</span><span class="n">V</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">$</span><span class="n">color</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rainbow</span><span class="p">(</span><span class="n">G</span><span class="p">)[</span><span class="n">group</span><span class="p">[</span><span class="nf">names</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">g</span><span class="p">))]]</span><span class="w"> </span><span class="c1">## color nodes by group</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">vertex.label</span><span class="o">=</span><span class="kc">NA</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="http://localhost:4000/assets/blog/graphigraph-1.png" alt="" /></p>

<p>In visualizing the graph, we can clearly see 5 very distinct communities corresponding to our simulated cell types. If we can see these distinct communities, surely a graph-based community detection method such as the <a href="https://www-complexnetworks.lip6.fr/~latapy/Publis/communities.pdf">walktrap algorithm</a> can detect them too.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">km</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">igraph</span><span class="o">::</span><span class="n">cluster_walktrap</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span><span class="c1">## community membership</span><span class="w">
</span><span class="n">com</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">km</span><span class="o">$</span><span class="n">membership</span><span class="w">
</span><span class="nf">names</span><span class="p">(</span><span class="n">com</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">km</span><span class="o">$</span><span class="n">names</span><span class="w">
</span><span class="n">table</span><span class="p">(</span><span class="n">com</span><span class="p">,</span><span class="w"> </span><span class="n">group</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##    group
## com group1 group2 group3 group4 group5
##   1    100      0      0      0      0
##   2      0    100      0      0      0
##   3      0      0      0      0    100
##   4      0      0      0    100      0
##   5      0      0    100      0      0
</code></pre></div></div>

<p>Do our identified communities match our simulated groups? Indeed they do! Community 1 corresponds to our group1 of cells, community 2 to our group2, community 3 to our group5, and so forth. However, this is a perfect simulated world. What happens when we apply this to real world data?</p>

<h2 id="10x-immune-cells">10X Immune Cells</h2>

<p>Consider this <a href="https://support.10xgenomics.com/single-cell-gene-expression/datasets">public dataset from 10X genomics</a>.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">Matrix</span><span class="p">)</span><span class="w">
</span><span class="n">load</span><span class="p">(</span><span class="s1">'reference_10x.RData'</span><span class="p">)</span><span class="w">
</span><span class="nf">dim</span><span class="p">(</span><span class="n">reference.cd</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 32738  2140
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">table</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## ct
##         bcells     cytotoxict        memoryt      monocytes naivecytotoxic 
##            330            148            252            129             43 
##         naivet             nk    regulatoryt        thelper 
##             52            769            226            191
</code></pre></div></div>

<p>Letâ€™s clean up this data a little. Weâ€™ll remove genes seen in fewer than 100 cells (a bit stringent, but itâ€™ll speed things up for this demonstration). Then weâ€™ll normalize and log transform.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vi</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">Matrix</span><span class="o">::</span><span class="n">rowSums</span><span class="p">(</span><span class="n">reference.cd</span><span class="o">&gt;</span><span class="m">0</span><span class="p">)</span><span class="o">&gt;</span><span class="m">100</span><span class="w">
</span><span class="n">table</span><span class="p">(</span><span class="n">vi</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## vi
## FALSE  TRUE 
## 27704  5034
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">reference.cd</span><span class="p">[</span><span class="n">vi</span><span class="p">,]</span><span class="w">
</span><span class="n">mat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="o">/</span><span class="n">colSums</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span><span class="w">
</span><span class="n">mat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">log10</span><span class="p">(</span><span class="n">mat</span><span class="o">*</span><span class="m">1e6+1</span><span class="p">)</span><span class="w">
</span><span class="n">mat</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">,</span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 5 x 5 Matrix of class "dgeMatrix"
##          bcellsAAAGATCTCCGAAT-1 bcellsAAAGCAGAGTACGT-1
## NOC2L                   0.00000                      0
## ISG15                   2.43014                      0
## TNFRSF18                2.43014                      0
## TNFRSF4                 0.00000                      0
## SDF4                    0.00000                      0
##          bcellsAAATCTGACCCTTG-1 bcellsAACAGCACTGAACC-1
## NOC2L                  0.000000               0.000000
## ISG15                  2.461924               2.432584
## TNFRSF18               0.000000               2.432584
## TNFRSF4                0.000000               0.000000
## SDF4                   2.461924               2.432584
##          bcellsAACATTGATGCTTT-1
## NOC2L                  2.799293
## ISG15                  3.099978
## TNFRSF18               0.000000
## TNFRSF4                0.000000
## SDF4                   0.000000
</code></pre></div></div>

<p>Now letâ€™s run our graph-based community detection to see if we recover the true cell type annotations.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">## identify KNN</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">RANN</span><span class="p">)</span><span class="w">
</span><span class="n">knn.info</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">RANN</span><span class="o">::</span><span class="n">nn2</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">mat</span><span class="p">),</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="m">30</span><span class="p">)</span><span class="w">

</span><span class="c1">## convert to adjacancy matrix</span><span class="w">
</span><span class="n">knn</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">knn.info</span><span class="o">$</span><span class="n">nn.idx</span><span class="w">
</span><span class="n">adj</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">matrix</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">ncol</span><span class="p">(</span><span class="n">mat</span><span class="p">),</span><span class="w"> </span><span class="n">ncol</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span><span class="w">
</span><span class="n">rownames</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colnames</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colnames</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="w">
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nf">seq_len</span><span class="p">(</span><span class="n">ncol</span><span class="p">(</span><span class="n">mat</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">colnames</span><span class="p">(</span><span class="n">mat</span><span class="p">)[</span><span class="n">knn</span><span class="p">[</span><span class="n">i</span><span class="p">,]]]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1">## convert to graph</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">igraph</span><span class="p">)</span><span class="w">
</span><span class="n">g</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">igraph</span><span class="o">::</span><span class="n">graph.adjacency</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="o">=</span><span class="s2">"undirected"</span><span class="p">)</span><span class="w">
</span><span class="n">g</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">simplify</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="c1">## remove self loops</span><span class="w">

</span><span class="c1">## identify communities</span><span class="w">
</span><span class="n">km</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">igraph</span><span class="o">::</span><span class="n">cluster_walktrap</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span><span class="n">com</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">km</span><span class="o">$</span><span class="n">membership</span><span class="w">
</span><span class="nf">names</span><span class="p">(</span><span class="n">com</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">km</span><span class="o">$</span><span class="n">names</span><span class="w">

</span><span class="c1">## compare to annotations</span><span class="w">
</span><span class="n">table</span><span class="p">(</span><span class="n">com</span><span class="p">,</span><span class="w"> </span><span class="n">ct</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##    ct
## com bcells cytotoxict memoryt monocytes naivecytotoxic naivet  nk
##   1      0          5      20         1              0      1   0
##   2      0          0       1       110              0      2   0
##   3    330          0       0        17              1      6   0
##   4      0        137     231         1             42     43   3
##   5      0          6       0         0              0      0 766
##    ct
## com regulatoryt thelper
##   1          16      15
##   2           3       8
##   3           0       0
##   4         207     168
##   5           0       0
</code></pre></div></div>

<p>Not perfect but not bad! Community 3 is predominantly b cells, community 4 is cytotoxic t cells, community 2 is monocytes, and so forth. There are lots of other community detection algorithms as well that we can try like <a href="http://www.mapequation.org/assets/publications/mapequationtutorial.pdf">infomap</a>.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">km</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">igraph</span><span class="o">::</span><span class="n">cluster_infomap</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w">
</span><span class="n">com</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">km</span><span class="o">$</span><span class="n">membership</span><span class="w">
</span><span class="nf">names</span><span class="p">(</span><span class="n">com</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">km</span><span class="o">$</span><span class="n">names</span><span class="w">
</span><span class="n">table</span><span class="p">(</span><span class="n">com</span><span class="p">,</span><span class="w"> </span><span class="n">ct</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##    ct
## com bcells cytotoxict memoryt monocytes naivecytotoxic naivet  nk
##   1      0        140     217         0             42     34   3
##   2      0          3       0         0              0      0 766
##   3    330          0       0         2              0      0   0
##   4      0          0       1       110              0      2   0
##   5      0          5      20         0              0      0   0
##   6      0          0      14         0              0      9   0
##   7      0          0       0        17              1      7   0
##    ct
## com regulatoryt thelper
##   1         208     165
##   2           0       0
##   3           0       0
##   4           3       8
##   5          14      13
##   6           1       4
##   7           0       1
</code></pre></div></div>

<p>And many many more. Check out the <code class="highlighter-rouge">igraph</code> package for more community detection algorithms available through the package: <a href="https://www.rdocumentation.org/packages/igraph/">https://www.rdocumentation.org/packages/igraph/</a></p>

<p>Now itâ€™s time for you to try it out for yourself. What if we change k in the k-nearest neighbor identification? What if we use fewer features/genes? What if we try a different community detection algorithm? What if we transpose our matrices and try to cluster genes instead of cells?</p>
:ET